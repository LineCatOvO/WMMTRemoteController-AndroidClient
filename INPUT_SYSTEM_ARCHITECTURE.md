# 输入系统架构文档

## 1. 概述

本文档描述了 WMMT 远程控制器的输入系统架构，该系统负责将 Android 设备的传感器数据和用户交互转换为游戏输入指令。

## 2. 核心设计原则

- **语义分离**: 清晰区分输入数据、处理逻辑和映射策略
- **状态与事件分离**: 明确区分持续状态输入和离散事件输入
- **单一职责**: 每个组件只负责一个特定功能
- **可扩展性**: 设计支持未来功能扩展（如配置 UI、多配置文件等）
- **可维护性**: 代码结构清晰，易于理解和修改
- **UI 与逻辑分离**: UI 组件仅负责呈现，系统节点负责逻辑处理

## 3. 架构组件

### 3.1 数据模型

#### RawInput

- **用途**: 存储原始传感器数据
- **内容**: 陀螺仪数据、触摸数据、按钮状态
- **来源**: 传感器服务和用户交互

#### GameInputState

- **用途**: 表示持续的游戏输入状态
- **内容**: 转向、油门、刹车的连续值
- **范围**: -1.0 到 1.0（转向），0.0 到 1.0（油门/刹车）

#### GameInputEvent

- **用途**: 表示离散的游戏输入事件
- **类型**: 按下、释放、点击、长按
- **特点**: 瞬时性，包含时间戳

#### InputState

- **用途**: 最终发送到服务器的输入状态
- **内容**: 键盘按键、鼠标状态、陀螺仪状态
- **格式**: 与服务器定义的 TypeScript 类型匹配

### 3.2 三层处理架构

#### 3.2.1 交互捕获层 (InteractionCapture)

- **职责**: 捕获和标准化原始输入（触控、陀螺仪、按键、游戏手柄等）
- **功能**: 采集原始输入数据，不涉及业务逻辑
- **特点**: 专注于输入数据的采集

#### 3.2.2 抽象操作层 (IntentComposer)

- **职责**: 将原始输入转换为抽象操作意图
- **功能**: 应用死区、平滑、曲线等处理算法
- **特点**: 纯逻辑处理，可独立测试

#### 3.2.3 设备映射层 (DeviceProjector)

- **职责**: 将抽象操作意图投影到具体的设备输出
- **功能**: 与服务端通信，发送输入状态
- **特点**: 确定性输出，严格合同

#### 3.2.4 三层架构图示

```
                    ┌─────────────────────────┐
                    │      UI Layer           │
                    │  (LayoutRenderer)       │
                    └─────────────┬───────────┘
                                  │
                    ┌─────────────▼───────────┐
                    │   InteractionCapture    │
                    │   (交互捕获层)          │
                    └─────────────┬───────────┘
                                  │
                    ┌─────────────▼───────────┐
                    │    IntentComposer       │
                    │   (抽象操作层)          │
                    └─────────────┬───────────┘
                                  │
                    ┌─────────────▼───────────┐
                    │   DeviceProjector       │
                    │   (设备映射层)          │
                    └─────────────┬───────────┘
                                  │
                    ┌─────────────▼───────────┐
                    │     WebSocket           │
                    │   (服务端通信)          │
                    └─────────────────────────┘
```

### 3.3 处理管线

#### InputPipeline

- **核心处理组件**
- **处理流程**: RawInput → 过滤 → 平滑 → 死区 → 曲线 → 语义分离 → 映射 → InputState
- **职责**: 协调各处理阶段，生成最终输入状态

#### 处理阶段

1. **数据预处理**: 过滤、平滑、死区、曲线映射
2. **语义分离**: 将原始数据转换为游戏语义（转向、油门、刹车）
3. **映射**: 将游戏语义映射为键盘按键

### 3.4 原始输入模块（全局、少量、稳定）

#### 输入源模块

- TouchInputSource
- GyroInputSource
- KeyInputSource

- 每种输入源一个模块
- 负责：采集、标准化、时间戳
- **完全不知道布局和 UI**

### 3.5 UI 与系统节点分离

#### UI 组件作为"Interaction Surface"

UI 组件应该是**被动的**：

- ThrottleView
- BrakeView
- GearButtonView
- SteeringWheelView

它们只做一件事：
> **声明"我对哪些 Interaction 感兴趣"**

例如：

- 一个区域
- 一个手势
- 一个方向
- 一个可视反馈

#### 系统节点（Interaction/Operation Node）

**Node 存在于逻辑层，而非 UI 层**，它们是：

- 由布局 JSON 定义
- 与 UI 解耦
- 可测试、可序列化、可回放

例如：

- AnalogControlNode
- ButtonControlNode
- GyroControlNode

它们：

- 接收来自 InputSource 的标准化事件
- 根据布局配置决定：
  - 是否命中
  - 如何转换
- 输出 Operation

### 3.6 映射策略

#### KeyboardMapping

- **用途**: 封装键盘映射逻辑
- **内容**: 方向键、油门、刹车、辅助按钮的映射
- **设计**: 可替换，支持未来的多配置文件

## 4. 数据流

```
传感器数据 → RawInput → InteractionCapture → IntentComposer → DeviceProjector → InputState → WebSocket → 服务器
        
用户交互 → RawInput → InteractionCapture → IntentComposer → DeviceProjector → InputState → WebSocket → 服务器
```

## 5. 代码结构

```
com.linecat.wmmtcontroller
├── input/
│   ├── InteractionCapture.java      # 交互捕获器
│   ├── IntentComposer.java          # 意图合成器
│   ├── DeviceProjector.java         # 设备投影器
│   ├── InputPipeline.java           # 输入处理管线
│   ├── KeyboardMapping.java         # 键盘映射策略
│   ├── GameInputState.java          # 游戏输入状态
│   └── GameInputEvent.java          # 游戏输入事件
├── model/
│   ├── RawInput.java                # 原始输入数据
│   └── InputState.java              # 最终输入状态
├── service/
│   └── SensorService.java           # 传感器服务
└── websocket/
    └── WebSocketService.java        # WebSocket服务
```

## 6. 未来扩展

### 6.1 配置系统

- 允许用户自定义键位映射
- 支持多配置文件（不同游戏/车辆）
- 提供配置 UI

### 6.2 高级输入处理

- 支持更多传感器类型
- 增加手势识别
- 支持力反馈

### 6.3 多设备支持

- 支持多设备输入组合
- 支持设备特定优化

## 7. 设计决策

### 7.1 状态与事件分离

- **原因**: 持续输入和离散输入需要不同的处理方式
- **优势**: 更清晰的代码结构，更好的性能，更灵活的扩展

### 7.2 映射策略分离

- **原因**: 映射逻辑可能因游戏和用户偏好而异
- **优势**: 易于修改映射，支持多配置，便于测试

### 7.3 清晰的处理流程

- **原因**: 输入处理是系统的核心，需要清晰的流程
- **优势**: 易于调试，便于修改处理逻辑，支持扩展新的处理阶段

### 7.4 三层架构设计

- **原因**: 避免 UI 与逻辑纠缠，确保系统可维护性
- **优势**: 模块化设计，职责分离，便于测试和扩展

### 7.5 UI 与系统节点分离

- **原因**: 避免 UI 组件过度承担逻辑职责，确保架构清晰
- **优势**: UI 可独立更换，逻辑可独立测试，系统可预测

## 8. 测试策略

- **单元测试**: 测试每个处理阶段的正确性
- **集成测试**: 测试完整的输入处理流程
- **功能测试**: 测试实际游戏控制效果
- **性能测试**: 测试输入延迟和处理效率

## 9. 结论

本输入系统架构设计遵循了现代软件工程原则，具有清晰的结构、良好的扩展性和可维护性。系统采用了三层架构设计，实现了UI与逻辑的有效分离，并为未来扩展打下了坚实基础。
